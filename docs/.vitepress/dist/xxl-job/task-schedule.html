<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>定时任务调度 | shengduiliang</title>
    <meta name="description" content="shengduiliang的博客网站">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/assets/style.h9vKkxRd.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.D5qdamUv.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.Dmxk2DJ4.js">
    <link rel="modulepreload" href="/assets/chunks/framework.P9qPzDnn.js">
    <link rel="modulepreload" href="/assets/xxl-job_task-schedule.md.B56rsZ3A.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>shengduiliang</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/spring-security/start.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Spring Security</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/xxl-job/start.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>xxl-job</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/shengduiliang" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/shengduiliang" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 collapsible collapsed" data-v-c40bc020 data-v-b7550ba0><div class="item" role="button" tabindex="0" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><h2 class="text" data-v-b7550ba0>Spring Security 6</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b7550ba0><span class="vpi-chevron-right caret-icon" data-v-b7550ba0></span></div></div><div class="items" data-v-b7550ba0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/start.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>入门与使用</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/form-login.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>表单登录认证</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/filter.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>架构分析(核心)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/http-security.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>SecurityFilterChain构建流程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/authentication.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>认证流程分析</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/session.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>用户会话管理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/exception.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>异常处理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/remember-me.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>RememberMe</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/authorities.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>权限管理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/spring-security/oauth2.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>OAtuh2认证流程</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-c40bc020 data-v-b7550ba0><div class="item" role="button" tabindex="0" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><h2 class="text" data-v-b7550ba0>xxl-job</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b7550ba0><span class="vpi-chevron-right caret-icon" data-v-b7550ba0></span></div></div><div class="items" data-v-b7550ba0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/start.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>入门与使用</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/xxl-job-concept.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>xxl-job概念详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/xxl-job-admin.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>xxl-job-admin目录结构与配置</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/user.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>用户管理与权限校验</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/xxl-job-admin-schedule.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>调度中心启动流程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/task-schedule.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>定时任务调度器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/trigger.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>定时任务执行流程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/route.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>路由选择策略</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/xxl-job/executor.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>执行器初始化流程</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _xxl-job_task-schedule" data-v-39a288b8><div><h1 id="定时任务调度" tabindex="-1">定时任务调度 <a class="header-anchor" href="#定时任务调度" aria-label="Permalink to &quot;定时任务调度&quot;">​</a></h1><p>上一篇分析了调度中心启动流程分析，调度中心启动过程中会启动调度任务。这一篇文章主要深入调度任务的启动源码。</p><p>我们从上节最后的那行代码JobScheduleHelper#getInstance#start方法讲起，查看该方法，可以看到定义了scheduleThread跟ringThread两个守护线程，代码如下:</p><div class="language-JobScheduleHelper vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JobScheduleHelper</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class JobScheduleHelper {</span></span>
<span class="line"><span>  public void start() {</span></span>
<span class="line"><span>    // scheduleThread</span></span>
<span class="line"><span>    scheduleThread = new Thread();</span></span>
<span class="line"><span>    scheduleThread.setDaemon(true);</span></span>
<span class="line"><span>    scheduleThread.setName(&quot;xxl-job, admin JobScheduleHelper#scheduleThread&quot;);</span></span>
<span class="line"><span>    scheduleThread.start();</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    // ringThread</span></span>
<span class="line"><span>    ringThread = new Thread();</span></span>
<span class="line"><span>    ringThread.setDaemon(true);</span></span>
<span class="line"><span>    ringThread.setName(&quot;xxl-job, admin JobScheduleHelper#ringThread&quot;);</span></span>
<span class="line"><span>    ringThread.start();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="schedulethread" tabindex="-1">scheduleThread <a class="header-anchor" href="#schedulethread" aria-label="Permalink to &quot;scheduleThread&quot;">​</a></h2><p>我们先看一下scheduleThread#run方法的处理逻辑，代码如下：</p><div class="language-JobScheduleHelper vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JobScheduleHelper</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>scheduleThread = new Thread(new Runnable() {</span></span>
<span class="line"><span>  @Override</span></span>
<span class="line"><span>  public void run() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 让当前线程休眠到下一个5s的时间，比如当前时间是12:00:00.345，则会休眠到12:00:05</span></span>
<span class="line"><span>    TimeUnit.MILLISECONDS.sleep(5000 - System.currentTimeMillis()%1000 );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20)</span></span>
<span class="line"><span>    // 下次执行时间在未来5秒以内的所有任务数，一次最多取（triggerPoolFastMax 200 +triggerPoolSlowMax 100）* 20条，最少6000条</span></span>
<span class="line"><span>    int preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    while (!scheduleThreadToStop) {</span></span>
<span class="line"><span>      boolean preReadSuc = true;</span></span>
<span class="line"><span>      try {</span></span>
<span class="line"><span>        //设置手动提交</span></span>
<span class="line"><span>        conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();</span></span>
<span class="line"><span>        connAutoCommit = conn.getAutoCommit();</span></span>
<span class="line"><span>        conn.setAutoCommit(false);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //获取任务调度锁表内数据信息,加写锁</span></span>
<span class="line"><span>        preparedStatement = conn.prepareStatement(  &quot;select * from xxl_job_lock where lock_name = &#39;schedule_lock&#39; for update&quot; );</span></span>
<span class="line"><span>        preparedStatement.execute();</span></span>
<span class="line"><span>        // 1、pre read</span></span>
<span class="line"><span>        long nowTime = System.currentTimeMillis();</span></span>
<span class="line"><span>        // 获取当前时间后5秒，同时最多负载的分页数</span></span>
<span class="line"><span>        List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);</span></span>
<span class="line"><span>        if (scheduleList!=null &amp;&amp; scheduleList.size()&gt;0) {</span></span>
<span class="line"><span>            ...</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            preReadSuc = false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      } finally {</span></span>
<span class="line"><span>        if (null != preparedStatement) {</span></span>
<span class="line"><span>            preparedStatement.close();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      // tx stop</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span>      long cost = System.currentTimeMillis()-start;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      // Wait seconds, align second</span></span>
<span class="line"><span>      if (cost &lt; 1000) {  // scan-overtime, not wait</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>          // pre-read period: success &gt; scan each second; fail &gt; skip this period;</span></span>
<span class="line"><span>          TimeUnit.MILLISECONDS.sleep((preReadSuc?1000:PRE_READ_MS) - System.currentTimeMillis()%1000);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>  }    </span></span>
<span class="line"><span>});</span></span></code></pre></div><p>这段线程主要是不断循环，然后对xxl_job_lock加写锁，然后获取未来5秒之内的所有任务，如果有任务则对任务进行处理，具体处理逻辑看后面。这里有个地方要重点说明一下，xxl-job在集群部署时，如何避免多个服务器同时调度任务呢？做法就是先对xxl_job_lock加写锁，只有加写锁成功才可以获取定时任务来处理，从而避免多个服务器同时调度任务；</p><ul><li>通过setAutoCommit(false)，关闭自动提交</li><li>通过select lock for update语句，其他事务无法获取到锁，显示排她锁。</li><li>进行定时调度任务的逻辑（这部分代码省略，在下面进行分析）</li><li>最后在finally块中commit()提交事务，并且setAutoCommit，释放for update的排他锁。</li></ul><p>上面代码，我们忽略了处理定时任务的细节，这里我们补上，看看xxl-job是怎么处理任务的。</p><div class="language-JobScheduleHelper vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JobScheduleHelper</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class JobScheduleHelper {</span></span>
<span class="line"><span>  public void start() {</span></span>
<span class="line"><span>    ....</span></span>
<span class="line"><span>    if (scheduleList!=null &amp;&amp; scheduleList.size()&gt;0) {</span></span>
<span class="line"><span>    // 2、push time-ring</span></span>
<span class="line"><span>      for (XxlJobInfo jobInfo: scheduleList) {</span></span>
<span class="line"><span>        // time-ring jump</span></span>
<span class="line"><span>        // 当前时间超过触发时间5秒后</span></span>
<span class="line"><span>        if (nowTime &gt; jobInfo.getTriggerNextTime() + PRE_READ_MS) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          // 2.1、trigger-expire &gt; 5s：pass &amp;&amp; make next-trigger-time</span></span>
<span class="line"><span>          logger.warn(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule misfire, jobId = &quot; + jobInfo.getId());</span></span>
<span class="line"><span>          // 1、misfire match</span></span>
<span class="line"><span>          // - 调度过期策略：</span></span>
<span class="line"><span>          // - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间； DO_NOTHING</span></span>
<span class="line"><span>          // - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间；FIRE_ONCE_NOW</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          MisfireStrategyEnum misfireStrategyEnum = MisfireStrategyEnum.match(jobInfo.getMisfireStrategy(), MisfireStrategyEnum.DO_NOTHING);</span></span>
<span class="line"><span>          if (MisfireStrategyEnum.FIRE_ONCE_NOW == misfireStrategyEnum) {</span></span>
<span class="line"><span>            // FIRE_ONCE_NOW 》 trigger</span></span>
<span class="line"><span>            JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.MISFIRE, -1, null, null, null);</span></span>
<span class="line"><span>            logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot; + jobInfo.getId() );</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          // 2、fresh next</span></span>
<span class="line"><span>          // 更新下次执行时间</span></span>
<span class="line"><span>          refreshNextValidTime(jobInfo, new Date());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        } else if (nowTime &gt; jobInfo.getTriggerNextTime()) {</span></span>
<span class="line"><span>          // 当前时间大于了下次执行时间，并且小于下次执行时间+5s，说明肯定要执行这个业务逻辑了</span></span>
<span class="line"><span>          // 2.2、trigger-expire &lt; 5s：direct-trigger &amp;&amp; make next-trigger-time</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          // 1、开始发执行路由规则定位到具体的节点执行</span></span>
<span class="line"><span>          JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -1, null, null, null);</span></span>
<span class="line"><span>          logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot; + jobInfo.getId() );</span></span>
<span class="line"><span>          // 2、执行完之后刷新下次执行的时间</span></span>
<span class="line"><span>          refreshNextValidTime(jobInfo, new Date());</span></span>
<span class="line"><span>          // next-trigger-time in 5s, pre-read again</span></span>
<span class="line"><span>          if (jobInfo.getTriggerStatus()==1 &amp;&amp; nowTime + PRE_READ_MS &gt; jobInfo.getTriggerNextTime()) {</span></span>
<span class="line"><span>            // 1、make ring second</span></span>
<span class="line"><span>            int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);</span></span>
<span class="line"><span>            // 2、push time ring</span></span>
<span class="line"><span>            pushTimeRing(ringSecond, jobInfo.getId());</span></span>
<span class="line"><span>            // 3、fresh next</span></span>
<span class="line"><span>            refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>          // 2.3、trigger-pre-read：time-ring trigger &amp;&amp; make next-trigger-time</span></span>
<span class="line"><span>          // 未来五秒以内执行的所有任务添加到ringData</span></span>
<span class="line"><span>          int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);</span></span>
<span class="line"><span>          // 2、push time ring</span></span>
<span class="line"><span>          pushTimeRing(ringSecond, jobInfo.getId());</span></span>
<span class="line"><span>          // 3、fresh next</span></span>
<span class="line"><span>          refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      // 3、update trigger info</span></span>
<span class="line"><span>      for (XxlJobInfo jobInfo: scheduleList) {</span></span>
<span class="line"><span>        XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>xxl_job_info表是记录定时任务的表，里面有个trigger_next_time（Long）字段，表示下一次任务被触发的时间，任务每被触发一次都要更新trigger_next_time字段，这样就知道任务何时被触发。定时任务的实现分成下面几步：</p><ul><li>从数据库中读取5秒内需要执行的任务，并遍历任务。</li><li>如果当前时间超过下一次触发时间5秒，获取此时调度任务已经过期的调度策略的配置，默认是什么也做策略。如果配置是立即执行一次策略，那么就立即触发定时任务，否则什么也不做。最后更新下一次触发时间。</li><li>如果当前时间超过下一次触发时间，但并没有超过5秒，立即触发一次任务，然后更新下一次触发时间。如果任务正在运行并且更新以后的触发时间在当前时间5秒内，将任务放进时间轮，然后再次更新下一次触发时间。因为触发时间太短了所以就放进时间轮中，供下一次触发。</li><li>如果不是上面的两种情况，则计算时间轮，将任务放进时间轮中，最后更新下一次触发时间。</li><li>更新调度任务信息保存到数据库中，更新trigger_next_time字段。</li></ul><p>最后我们总结一下scheduleThread的代码流程。</p><p><img src="/assets/scheduleThread._ZicOhLA.png" alt="scheduleThread"></p><h2 id="ringthread" tabindex="-1">ringThread <a class="header-anchor" href="#ringthread" aria-label="Permalink to &quot;ringThread&quot;">​</a></h2><p>在了解ringThread之前，大家有必要了解一下时间轮算法，如果想对时间轮算法不熟悉的话，可以点击<a href="https://www.bilibili.com/video/BV1ry4y1k7E6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a9e3a92001a310c0b5dad25cc5899f99" target="_blank" rel="noreferrer">此处</a>查看。</p><img src="/assets/timer-wheel.CyYtWtZT.png" width="600" alt="timer-wheel"><p>这里简单地讲一下xxl-job的时间轮算法，xxl-job使用了一个Map维护了一个分钟级别的时间轮，共有60个桶，然后每隔1秒钟前进一个刻度，并且取出该刻度的任务来处理。</p><div class="language-JobScheduleHelper vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JobScheduleHelper</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public class JobScheduleHelper {</span></span>
<span class="line"><span>  private volatile static Map&lt;Integer, List&lt;Integer&gt;&gt; ringData = new ConcurrentHashMap&lt;&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  public void start() {</span></span>
<span class="line"><span>    scheduleThread = new Thread(new Runnable() {</span></span>
<span class="line"><span>      public void run() {</span></span>
<span class="line"><span>        ...</span></span>
<span class="line"><span>        // 1、make ring second</span></span>
<span class="line"><span>        int ringSecond = (int)((jobInfo.getTriggerNextTime()/1000)%60);</span></span>
<span class="line"><span>        // 2、push time ring</span></span>
<span class="line"><span>        pushTimeRing(ringSecond, jobInfo.getId());</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>可以看到scheduleThread在处理当前时间大于下次触发时间的时候，是直接放入ringData当中的，而放入ringData的key就是获取任务下次触发的时间对60取余。</p><p>我们看看ringThread的处理逻辑，代码如下:</p><div class="language-JobScheduleHelper vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JobScheduleHelper</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ringThread = new Thread(new Runnable() {</span></span>
<span class="line"><span>  @Override</span></span>
<span class="line"><span>  public void run() {</span></span>
<span class="line"><span>    while (!ringThreadToStop) {</span></span>
<span class="line"><span>      // align second, 在每个整秒执行</span></span>
<span class="line"><span>      TimeUnit.MILLISECONDS.sleep(1000 - System.currentTimeMillis() % 1000);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      try {</span></span>
<span class="line"><span>        // second data</span></span>
<span class="line"><span>        List&lt;Integer&gt; ringItemData = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>        // 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span></span>
<span class="line"><span>        // 获取当前的秒数</span></span>
<span class="line"><span>        int nowSecond = Calendar.getInstance().get(Calendar.SECOND);   </span></span>
<span class="line"><span>        // 取两个刻度</span></span>
<span class="line"><span>        for (int i = 0; i &lt; 2; i++) {</span></span>
<span class="line"><span>          List&lt;Integer&gt; tmpData = ringData.remove( (nowSecond+60-i)%60 );</span></span>
<span class="line"><span>          if (tmpData != null) {</span></span>
<span class="line"><span>            ringItemData.addAll(tmpData);</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // ring trigger</span></span>
<span class="line"><span>        logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, time-ring beat : &quot; + nowSecond + &quot; = &quot; + Arrays.asList(ringItemData) );</span></span>
<span class="line"><span>        if (ringItemData.size() &gt; 0) {</span></span>
<span class="line"><span>          // do trigger</span></span>
<span class="line"><span>          for (int jobId: ringItemData) {</span></span>
<span class="line"><span>            // do trigger，执行定时任务</span></span>
<span class="line"><span>            JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -1, null, null, null);</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span>          // clear</span></span>
<span class="line"><span>          ringItemData.clear();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>});</span></span></code></pre></div><p>这块代码很好理解，ringThread线程的run方法首先获取当前的时间（秒数），然后从时间轮内移出当前秒数前2个秒数的任务列表，遍历任务列表触发任务的执行，最后清空已经执行的任务列表。这里获取当前秒数前2个秒数的任务列表是因为避免处理时间太长导致错失了调度。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>如果ringThread线程被阻塞了很长时间，导致每次执行的时间超过了2秒，那么有可能会丢任务，还好的就是这是一个循环的时间轮，1min后可以再次被扫描到执行。</p></div><p>在上面的代码中，有一个很重要的方法，就是触发执行器处理定时任务，代码如下，下个章节我们分析这个方法的执行逻辑。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JobTriggerPoolHelper.trigger();</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/xxl-job/xxl-job-admin-schedule.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>调度中心启动流程</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/xxl-job/trigger.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>定时任务执行流程</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CnDJ-2zd\",\"spring-security_authentication.md\":\"DNBYhsct\",\"spring-security_authorities.md\":\"CTl3r-Pg\",\"spring-security_exception.md\":\"BgEBNtLM\",\"spring-security_filter.md\":\"D0qKTjii\",\"spring-security_form-login.md\":\"Bauxdp12\",\"spring-security_http-security.md\":\"L2zBhObC\",\"spring-security_oauth2.md\":\"Doxuru36\",\"spring-security_remember-me.md\":\"B7A3SidS\",\"spring-security_session.md\":\"DaFLM4d2\",\"spring-security_start.md\":\"6KeARqab\",\"xxl-job_executor.md\":\"DRqcklGf\",\"xxl-job_route.md\":\"CmMgsM_e\",\"xxl-job_start.md\":\"gVXtP_aD\",\"xxl-job_task-schedule.md\":\"B56rsZ3A\",\"xxl-job_trigger.md\":\"C5BEew1P\",\"xxl-job_user.md\":\"BOR-fe_e\",\"xxl-job_xxl-job-admin-schedule.md\":\"BwHMhmsO\",\"xxl-job_xxl-job-admin.md\":\"B-T_zyRK\",\"xxl-job_xxl-job-concept.md\":\"B0N7xbVb\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"shengduiliang\",\"description\":\"shengduiliang的博客网站\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Spring Security\",\"link\":\"/spring-security/start\"},{\"text\":\"xxl-job\",\"link\":\"/xxl-job/start\"}],\"sidebar\":[{\"collapsed\":true,\"text\":\"Spring Security 6\",\"items\":[{\"text\":\"入门与使用\",\"link\":\"/spring-security/start\"},{\"text\":\"表单登录认证\",\"link\":\"/spring-security/form-login\"},{\"text\":\"架构分析(核心)\",\"link\":\"/spring-security/filter\"},{\"text\":\"SecurityFilterChain构建流程\",\"link\":\"/spring-security/http-security\"},{\"text\":\"认证流程分析\",\"link\":\"/spring-security/authentication\"},{\"text\":\"用户会话管理\",\"link\":\"/spring-security/session\"},{\"text\":\"异常处理\",\"link\":\"/spring-security/exception\"},{\"text\":\"RememberMe\",\"link\":\"/spring-security/remember-me\"},{\"text\":\"权限管理\",\"link\":\"/spring-security/authorities\"},{\"text\":\"OAtuh2认证流程\",\"link\":\"/spring-security/oauth2\"}]},{\"collapsed\":true,\"text\":\"xxl-job\",\"items\":[{\"text\":\"入门与使用\",\"link\":\"/xxl-job/start\"},{\"text\":\"xxl-job概念详解\",\"link\":\"/xxl-job/xxl-job-concept\"},{\"text\":\"xxl-job-admin目录结构与配置\",\"link\":\"/xxl-job/xxl-job-admin\"},{\"text\":\"用户管理与权限校验\",\"link\":\"/xxl-job/user\"},{\"text\":\"调度中心启动流程\",\"link\":\"/xxl-job/xxl-job-admin-schedule\"},{\"text\":\"定时任务调度器\",\"link\":\"/xxl-job/task-schedule\"},{\"text\":\"定时任务执行流程\",\"link\":\"/xxl-job/trigger\"},{\"text\":\"路由选择策略\",\"link\":\"/xxl-job/route\"},{\"text\":\"执行器初始化流程\",\"link\":\"/xxl-job/executor\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/shengduiliang\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>