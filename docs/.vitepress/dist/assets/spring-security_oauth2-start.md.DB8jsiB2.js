import{_ as a}from"./chunks/Oauth2-server-architecture.CFAPET59.js";import{_ as n,c as e,a0 as p,o as t}from"./chunks/framework.P9qPzDnn.js";const o="/assets/wechat-login.DCj0jACl.png",i="/assets/%E9%9A%90%E5%BC%8F%E6%A8%A1%E5%BC%8F.FPavWyBb.png",c="/assets/%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F.BrMMRwC1.png",l="/assets/Client%20Credentials.DMOkF6ad.png",r="/assets/JWT.BwTvd8Wr.png",O=JSON.parse('{"title":"OAuth2模型介绍","description":"","frontmatter":{},"headers":[],"relativePath":"spring-security/oauth2-start.md","filePath":"spring-security/oauth2-start.md"}'),u={name:"spring-security/oauth2-start.md"};function d(h,s,k,b,m,q){return t(),e("div",null,s[0]||(s[0]=[p('<h1 id="oauth2模型介绍" tabindex="-1">OAuth2模型介绍 <a class="header-anchor" href="#oauth2模型介绍" aria-label="Permalink to &quot;OAuth2模型介绍&quot;">​</a></h1><p>OAuth是一个开放标准，该标准允许用户让第三方应用访问该用户在某一个网站上存储的私密资源（如头像，照片，视频等），并且在这个过程中无须将用户名和密码提供给第三方应用，通过令牌（Token）可以实现这个功能，每一个令牌授权一个特定的网站在特定的时段内允许特定的资源。</p><img src="'+o+'" width="500" alt="wechat-login"><p>举个例子说明一下，比如用户想在微信小程序中登录我们的应用，那么我们的应用就要访问用户在微信服务器上的一些基本信息，比如手机号，OpenId这些，但是这些信息需要用户的授权，如果用户把自己的微信帐号密码告诉我们的应用，那么我们就可以拿到用户在微信服务器上的所有数据了，这种授权方式很明显就不安全，所以就引入OAuth这种协议，现在支持最新OAuth2.1协议。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>微信小程序登录这种场景跟常用的OAuth协议有些区别，这是微信自己的协议。</p></div><p>接下来我们看一下OAuth的几种授权模式。</p><h2 id="授权码模式" tabindex="-1">授权码模式 <a class="header-anchor" href="#授权码模式" aria-label="Permalink to &quot;授权码模式&quot;">​</a></h2><p>授权码模式适合应用具备后端服务器的场景。授权码模式要求应用必须能够安全存储密钥，用于后续使用授权码换 Access Token。授权码模式需要通过浏览器与终端用户交互完成认证授权，然后通过浏览器重定向将授权码发送到后端服务，之后进行授权码换 Token 以及 Token 换用户信息。</p><p><img src="'+a+'" alt="oauth2-server-architecture"></p><h2 id="隐式模式" tabindex="-1">隐式模式 <a class="header-anchor" href="#隐式模式" aria-label="Permalink to &quot;隐式模式&quot;">​</a></h2><p>隐式模式适合不能安全存储密钥的场景（例如前端浏览器）。在隐式模式中，应用不需要使用code换token，无需请求/token 端点，AccessToken 和 IdToken 会直接从认证端点返回。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>因为隐式模式用于不能安全存储密钥的场景，所以隐式模式不支持获取Refresh Token。</p></div><p><img src="'+i+'" alt="隐式模式"></p><h2 id="密码模式" tabindex="-1">密码模式 <a class="header-anchor" href="#密码模式" aria-label="Permalink to &quot;密码模式&quot;">​</a></h2><p>密码模式适用于你既掌握应用程序又掌握应用所需资源的场景。密码模式要求应用能够安全存储密钥，并且能够被信任地存储资源所有者的账密。一般常见于自家应用使用自家的资源。密码模式不需要重定向跳转，只需要携带用户账密访问 Token 端点。</p><p><img src="'+c+'" alt="密码模式"></p><h2 id="客户端模式" tabindex="-1">客户端模式 <a class="header-anchor" href="#客户端模式" aria-label="Permalink to &quot;客户端模式&quot;">​</a></h2><p>客户端模式用于进行服务器对服务器间的授权（M2M 授权），期间没有用户的参与。你需要创建编程访问账号，并将 AK、SK 密钥对交给你的资源调用方。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>客户端模式不支持 Refresh Token。</p></div><p><img src="'+l+`" alt="客户端"></p><h2 id="oidc" tabindex="-1">OIDC <a class="header-anchor" href="#oidc" aria-label="Permalink to &quot;OIDC&quot;">​</a></h2><p>OpenID Connect协议，简称OIDC，在Oauth2的基础上，增加了Id Token，能够认证用户并完成资源授权。在可以选择OIDC的情况下，应该选择OIDC。</p><p>在 OIDC 规范 (opens new window)中，有些名词与 OAuth 2.0 有区别：</p><ul><li>OpenID Provider，指授权服务器，负责签发 Id Token。Authing是 OpenID Provider。</li><li>终端用户，Id Token 的信息中会包含终端用户的信息。</li><li>调用方，请求 Id Token 的应用。</li><li>Id Token 由 OpenID Provider 颁发，包含关于终端用户的信息字段。</li><li>Claim 指终端用户信息字段。</li></ul><h2 id="id-token" tabindex="-1">ID Token <a class="header-anchor" href="#id-token" aria-label="Permalink to &quot;ID Token&quot;">​</a></h2><p>ID Token本质上是一个JWT Token，包含了该用户身份信息相关的key/value键值对，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>   &quot;iss&quot;: &quot;https://server.example.com&quot;,</span></span>
<span class="line"><span>   &quot;sub&quot;: &quot;24400320&quot;, // subject 的缩写，为用户 ID</span></span>
<span class="line"><span>   &quot;aud&quot;: &quot;s6BhdRkqt3&quot;,</span></span>
<span class="line"><span>   &quot;nonce&quot;: &quot;n-0S6_WzA2Mj&quot;,</span></span>
<span class="line"><span>   &quot;exp&quot;: 1311281970,</span></span>
<span class="line"><span>   &quot;iat&quot;: 1311280970,</span></span>
<span class="line"><span>   &quot;auth_time&quot;: 1311280969,</span></span>
<span class="line"><span>   &quot;acr&quot;: &quot;urn:mace:incommon:iap:silver&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="jwt" tabindex="-1">JWT <a class="header-anchor" href="#jwt" aria-label="Permalink to &quot;JWT&quot;">​</a></h2><p>JSON Web Token (JWT，RFC 7519 (opens new window))，是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519)。该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p><p><img src="`+r+`" alt="JWT"></p><p>想要解析JWT字符串，可以访问这个<a href="https://jwt.io/" target="_blank" rel="noreferrer">网站</a></p><p><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noreferrer">什么是JWT</a></p><h2 id="access-token" tabindex="-1">Access Token <a class="header-anchor" href="#access-token" aria-label="Permalink to &quot;Access Token&quot;">​</a></h2><p>Access Token 用于基于 Token 的认证模式，允许应用访问一个资源 API。用户认证授权成功后，Authing 会签发 Access Token 给应用。应用需要携带 Access Token 访问资源 API，资源服务 API 会通过拦截器查验 Access Token 中的 scope 字段是否包含特定的权限项目，从而决定是否返回资源。</p><p>如果你的用户通过社交账号登录，例如微信登录，微信作为身份提供商会颁发自己的 Access Token，你的应用可以利用 Access Token 调用微信相关的 API。这些 Access Token 是由社交账号服务方控制的，格式也是任意的。</p><h3 id="opaque-access-token" tabindex="-1">Opaque Access Token <a class="header-anchor" href="#opaque-access-token" aria-label="Permalink to &quot;Opaque Access Token&quot;">​</a></h3><p>Opaque Access Token 是一串随机字符串，从中不能获取到任何信息，你需要将它发送到服务器进行解析。只能通过将 Token 发到服务器的方式来验证 Opaque Access Token。</p><h3 id="jwt-access-token" tabindex="-1">JWT Access Token <a class="header-anchor" href="#jwt-access-token" aria-label="Permalink to &quot;JWT Access Token&quot;">​</a></h3><p>JWT 全称为 JSON Web Token (opens new window)，遵循 JWT 标准。JWT 中包含了主体、受众、权限、颁发时间、过期时间、用户信息字段等内容且具备签名，不可篡改。因此无需发送到服务器，可以本地验证。Authing 在大多数情况下使用此种格式的 Token。</p><h3 id="access-token-示例" tabindex="-1">Access Token 示例 <a class="header-anchor" href="#access-token-示例" aria-label="Permalink to &quot;Access Token 示例&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjF6aXlIVG15M184MDRDOU1jUENHVERmYWJCNThBNENlZG9Wa3VweXdVeU0ifQ</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>解析后的内容</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>解析后的内容：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;jti&quot;: &quot;3YByyfvL0xoMP5wpMulgL&quot;,</span></span>
<span class="line"><span>  &quot;sub&quot;: &quot;60194296801dc7bc2a1b2735&quot;, // subject 的缩写，为用户 ID</span></span>
<span class="line"><span>  &quot;iat&quot;: 1612444871,</span></span>
<span class="line"><span>  &quot;exp&quot;: 1613654471,</span></span>
<span class="line"><span>  &quot;scope&quot;: &quot;openid email message&quot;,</span></span>
<span class="line"><span>  &quot;iss&quot;: &quot;https://steam-talk.authing.cn/oidc&quot;,</span></span>
<span class="line"><span>  &quot;aud&quot;: &quot;60193c610f9117e7cb049159&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="refresh-token" tabindex="-1">Refresh Token <a class="header-anchor" href="#refresh-token" aria-label="Permalink to &quot;Refresh Token&quot;">​</a></h2><p>AccessToken和IdToken是 JSON Web Token (opens new window)，有效时间通常较短。通常用户在获取资源的时候需要携带AccessToken，当AccessToken过期后，用户需要获取一个新的 AccessToken。</p><p>Refresh Token用于获取新的AccessToken。这样可以缩短AccessToken的过期时间保证安全，同时又不会因为频繁过期重新要求用户登录。</p><p>用户在初次认证时，Refresh Token 会和 AccessToken、IdToken一起返回。你的应用必须安全地存储Refresh Token，它的重要性和密码是一样的，因为Refresh Token 能够一直让用户保持登录。</p><p>以下是 Token 端点返回的 Refresh Token：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;access_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InIxTGtiQm8zOTI1UmIyWkZGckt5VTNNVmV4OVQyODE3S3gwdmJpNmlfS2MifQ.eyJqdGkiOiJ4R01uczd5cmNFckxiakNRVW9US1MiLCJzdWIiOiI1YzlmNzVjN2NjZjg3YjA1YTkyMWU5YjAiLCJpc3MiOiJodHRwczovL2F1dGhpbmcuY24iLCJpYXQiOjE1NTQ1Mzc4NjksImV4cCI6MTU1NDU0MTQ2OSwic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBvZmZsaW5lX2FjY2VzcyBwaG9uZSBlbWFpbCIsImF1ZCI6IjVjYTc2NWUzOTMxOTRkNTg5MWRiMTkyNyJ9.wX05OAgYuXeYM7zCxhrkvTO_taqxrCTG_L2ImDmQjMml6E3GXjYA9EFK0NfWquUI2mdSMAqohX-ndffN0fa5cChdcMJEm3XS9tt6-_zzhoOojK-q9MHF7huZg4O1587xhSofxs-KS7BeYxEHKn_10tAkjEIo9QtYUE7zD7JXwGUsvfMMjOqEVW6KuY3ZOmIq_ncKlB4jvbdrduxy1pbky_kvzHWlE9El_N5qveQXyuvNZVMSIEpw8_y5iSxPxKfrVwGY7hBaF40Oph-d2PO7AzKvxEVMamzLvMGBMaRAP_WttBPAUSqTU5uMXwMafryhGdIcQVsDPcGNgMX6E1jzLA&quot;,</span></span>
<span class="line"><span>  &quot;expires_in&quot;: 3600,</span></span>
<span class="line"><span>  &quot;id_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InIxTGtiQm8zOTI1UmIyWkZGckt5VTNNVmV4OVQyODE3S3gwdmJpNmlfS2MifQ.eyJzdWIiOiI1YzlmNzVjN2NjZjg3YjA1YTkyMWU5YjAiLCJub25jZSI6IjIyMTIxIiwiYXRfaGFzaCI6Ik5kbW9iZVBZOEFFaWQ2T216MzIyOXciLCJzaWQiOiI1ODM2NzllNC1lYWM5LTRjNDEtOGQxMS1jZWFkMmE5OWQzZWIiLCJhdWQiOiI1Y2E3NjVlMzkzMTk0ZDU4OTFkYjE5MjciLCJleHAiOjE1NTQ1NDE0NjksImlhdCI6MTU1NDUzNzg2OSwiaXNzIjoiaHR0cHM6Ly9hdXRoaW5nLmNuIn0.IQi5FRHO756e_eAmdAs3OnFMU7QuP-XtrbwCZC1gJntevYJTltEg1CLkG7eVhdi_g5MJV1c0pNZ_xHmwS0R-E4lAXcc1QveYKptnMroKpBWs5mXwoOiqbrjKEmLMaPgRzCOdLiSdoZuQNw_z-gVhFiMNxI055TyFJdXTNtExt1O3KmwqanPNUi6XyW43bUl29v_kAvKgiOB28f3I0fB4EsiZjxp1uxHQBaDeBMSPaRVWQJcIjAJ9JLgkaDt1j7HZ2a1daWZ4HPzifDuDfi6_Ob1ZL40tWEC7xdxHlCEWJ4pUIsDjvScdQsez9aV_xMwumw3X4tgUIxFOCNVEvr73Fg&quot;,</span></span>
<span class="line"><span>  &quot;refresh_token&quot;: &quot;WPsGJbvpBjqXz6IJIr1UHKyrdVF&quot;,</span></span>
<span class="line"><span>  &quot;scope&quot;: &quot;openid profile offline_access phone email&quot;,</span></span>
<span class="line"><span>  &quot;token_type&quot;: &quot;Bearer&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>应用携带 Refresh Token 向 Token 端点发起请求时，一般每次都会返回相同的Refresh Token 和新的 AccessToken、IdToken，直到 Refresh Token 过期。</p><p>本篇文章参考: <a href="https://docs.authing.cn/v2/concepts/oidc/oidc-overview.html" target="_blank" rel="noreferrer">https://docs.authing.cn/v2/concepts/oidc/oidc-overview.html</a></p>`,51)]))}const g=n(u,[["render",d]]);export{O as __pageData,g as default};
